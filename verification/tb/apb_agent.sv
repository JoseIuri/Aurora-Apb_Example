/**
  ******************************************************************************
  * File automatic generated by XGeneratorTB software
  ******************************************************************************
**/
class apb_agentConfig extends uvm_object;

    // UVM Factory Registration Macro
    //
    `uvm_object_utils(apb_agentConfig)

    //------------------------------------------
    // Data Members
    //------------------------------------------

    // include the functional coverage or not
    bit hasCoverage = 0;

    // active or passive
    bit isActive = 1;

    //------------------------------------------
    // Methods
    //------------------------------------------

    function new(string name = "apb_agentConfig");
        super.new(name);
    endfunction

endclass:apb_agentConfig

class apb_agent extends uvm_agent;

    //------------------------------------------
    // Data Members
    //------------------------------------------
    apb_agentConfig cfg;

    static string MSGID = "apb__agent";

    `uvm_component_utils(apb_agent)

    //------------------------------------------
    // Component Members
    //------------------------------------------
    uvm_analysis_port #(apb_transaction) ap_req;
    uvm_analysis_port #(apb_transaction) ap_resp;

    uvm_sequencer#(apb_transaction) sqr;
    apb_monitor mon;
    apb_driver drv;
    apb_coverage cov;

    //------------------------------------------
    // Methods
    //------------------------------------------
    // Standard Methods
    extern function new (string name = "apb_agent", uvm_component parent = null);
    extern function void build_phase (uvm_phase phase);
    extern function void connect_phase (uvm_phase phase);

endclass: apb_agent

////////////////////////////////////////////////////////////////////////////////
// Implementation
//------------------------------------------------------------------------------
// Constructor
function apb_agent::new (string name = "apb_agent", uvm_component parent = null);
    super.new(name, parent);

    ap_req = new("ap_req", this);
    ap_resp = new("ap_resp", this);

    this.cfg = new();
endfunction

//------------------------------------------------------------------------------
// Construct sub-components
// retrieve and set sub-component configuration
//
function void apb_agent::build_phase (uvm_phase phase);
    super.build_phase(phase);
    // if(!uvm_config_db #(apb_agentConfig)::get(this, "apb_agentConfig", cfg))begin
    //     `uvm_error(MSGID,"Failed to get agent's config object: apb_agentConfig")
    // end
    // Monitor is always present
    mon = apb_monitor::type_id::create("mon", this);
    // Only build the driver and sequencer if active
    if(cfg.isActive == 1)begin
        sqr = uvm_sequencer#(apb_transaction)::type_id::create("sqr", this);
        drv = apb_driver::type_id::create("drv", this);
    end
    if(cfg.hasCoverage)begin
        cov = apb_coverage::type_id::create("cov", this);
    end
endfunction: build_phase

//------------------------------------------------------------------------------
// Connect sub-components
//
function void apb_agent::connect_phase (uvm_phase phase);
    mon.req.connect(ap_req);
    mon.resp.connect(ap_resp);
    // Only connect the driver and the sequencer if active
    if(cfg.isActive == 1) begin
        drv.seq_item_port.connect(sqr.seq_item_export);
    end
    if(cfg.hasCoverage) begin
        mon.req.connect(cov.collected_port);
    end
endfunction: connect_phase
